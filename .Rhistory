data <- read.csv("./data/基金会财务信息年分权重后结果统计（分类后）.csv", encoding = "utf-8")
View(data)
View(data)
install.packages("discretization")
colnames(data)
cols <- colnames(data)
data[cols]
View(data)
cols
cols[1]
cols[2]
cols[3]
choiceCol <- cols[c(7, 12, 11, 22)]
choiceCol
choiceCol <- cols[c(7, 12, 11, 22, 23)]
choiceCol
dataTrain <- data[choiceCol]
View(dataTrain)
row(dataTrain)
row.names(dataTrain)
head(data)
row.names(data)
cols
row.names(dataTrain) <- data[cols[1]]
mmapply
? mapply()
dataTrain$
dataTrain$净资产
dataTrain$净资产
dataTrain[2]
dataTrain[1]
dataTrain[2] <- dataTrain[2] / dataTrain[1]
is.na(dataTrain[2])
any(is.na(dataTrain[2]))
any(is.infinite(dataTrain[2]))
any(apply(is.infinite, dataTrain[2]))
any(apply(dataTrain[2], is.infinite))
any(lapply(dataTrain[2], is.infinite))
is.infinite(x)
dataTrain[3] <- dataTrain[3] / dataTrain[1]
dataTrain[4] <- dataTrain[4] / dataTrain[1]
head(dataTrain, n = 2)
library(discretization)
?? `discretization-package''
''
?? `discretization-package`
?? discretization
dataDisc <- cacc(dataTrain)
X <- matrix(dataTrain, nrow = nrow(dataTrain))
dataDisc <- cacc(dataTrain)
View(X)
X <- data.matrix(dataTrain)
dataDisc <- cacc(X)
View(X)
cacc(X)
dataDisc <- disc.Topdown(X, method = 2)
View(X)
View(X)
dataDisc <- disc.Topdown(X, method = 2)
class(X)
apply(X, 2, type)
apply(X, 2, class)
res <- disc.Topdown(X, method = 1)
X
ncol(X)
chiM(X)
iris
ncol(iris)
apply(iris, 2, class)
X[3]
class(iris)
dataTrain$label <- as.factor(dataTrain$label)
res <- disc.Topdown(dataTrain, method = 1)
res
res <- disc.Topdown(dataTrain, method = 2)
res$Disc.data
res <- disc.Topdown(dataTrain, method = 1)
res$Disc.data
resMDLP <- mdlp(dataTrain)
resMDLP <- mdlp(dataTrain)
x <- dataTrain[1]
x
hist(x, breaks = 20, main = "Data")
class(x)
x <- dataTrain[, 1]
hist(x, breaks = 20, main = "Data")
hist(x, breaks = 10, main = "Data")
hist(x, breaks = 4, main = "Data")
def.par <- par(no.readonly = TRUE) # save default
layout(mat=rbind(1:2,3:4))
### convert continuous variables into categories (there are 3 types of flowers)
### default is equal interval width
table(discretize(x, categories=3))
hist(x, breaks=5, main="Equal Interval length")
abline(v = discretize(x, categories=3, onlycuts=TRUE), col="red")
install.packages("manipulate")
??discretization
modChi2(dataTrain)
resModChid2 <- modChi2(dataTrain)
install.packages("discretize")
install.packages("arules")
x <- dataTrain[, 1]
x
library(arules)
?? discretize
xEqualFreq <- discretize(x, method = 'interval', categories = 3)
xEqualFreq
xEqualFreq <- discretize(x, method = 'interval', categories = 3, labels = c(0, 1, 2))
xEqualFreq
xEqualFreq <- discretize(x, method = 'frequency', categories = 3, labels = c(0, 1, 2))
xEqualFreq
install.packages("plyr")
library(plyr)
fnDisc <- function(X, method){
return (discretize(X, method, categories = 3, labels=c(0,1,2)))
}
fnDisc <- function(X, method){
return (discretize(X, method, categories = 3, labels=c(0,1,2)))
}
col(dataTrain)
dataTrain[c(1,2,3)]
dataTrain[c(1,2,3,4)]
colwise(fnDisc(method = 'frequency'))(dataTrain[c(1,2,3)])
??colwise
colwise(fnDisc)(dataTrain[c(1,2,3)], method='frequency')
Y <- dataTrain[, 4]
Y
Y <- dataTrain[, 3]
dataTrain
Y <- dataTrain[cols[4]]
Y <- dataTrain[col[4]]
Y <- dataTrain[, 4]
Y
ncol(dataTrain)
colnames(dataTrain)
Y <- dataTrain$label
1:3
XEqualInterval <- colwise(fnDisc)(dataTrain[c(1:3)], method='interval')
XEqualInterval <- colwise(fnDisc)(dataTrain[1:3], method='interval')
dataTrain
View(dataTrain)
View(data)
data[600,]
# discretization finantial data -------------------------------------------
data <- read.csv("./data/基金会财务信息年分权重后结果统计（分类后）.csv", encoding = "utf-8")
cols <- colnames(data)
choiceCol <- cols[c(7, 12, 11, 22, 23)]
dataTrain <- data[choiceCol]
# to make shou ru, zhi chu, fei yong smaller than 1
dataTrain[2] <- dataTrain[2] / dataTrain[1]
dataTrain[3] <- dataTrain[3] / dataTrain[1]
dataTrain[4] <- dataTrain[4] / dataTrain[1]
View(data)
View(dataTrain)
XEqualFreq <- colwise(fnDisc)(dataTrain[c(1:3)], method='frequency')
XEqualInterval <- colwise(fnDisc)(dataTrain[1:3], method='interval')
XCluster <- colwise(fnDisc)(dataTrain[1:3])
??colwise
??discretize
XEqualFreq <- colwise(fnDisc)(dataTrain[c(1:3)], method='frequency')
XEqualInterval <- colwise(fnDisc)(dataTrain[1:3], method='interval')
XCluster <- colwise(fnDisc)(dataTrain[1:3], method='cluster')
install.packages("caret")
library(caret)
split = 0.6
trainIndex <- createDataPartition(dataTrain$label, p = split, list=FALSE)
install.packages("klaR")
library(klaR)
fnClf <- function(Xtrian, Xtest, Ytrain, Ytest){
model <- NaiveBayes(Ytrain~Xtrain)
Ypred <- predict(model, Xtest)
confusionMatrix(Ypred$class, Ytest)
}
trainIndex <- createDataPartition(dataTrain$label, p = split, list=FALSE)
fnClf <- function(X, Y){
Xtrain <- X[trainIndex, ]
Xtest <- X[-trainIndex, ]
Ytrain <- Y[trainIndex]
Ytest <- Y[-trainIndex]
model <- NaiveBayes(Ytrain~Xtrain)
Ypred <- predict(model, Xtest)
confusionMatrix(Ypred$class, Ytest)
}
fnClf(XEqualFreq, Y)
View(XCluster)
addY <- function(X, Y){
X$target <- Y
}
addY(XEqualFreq)
addY(XEqualFreq, Y)
addY(XEqualInterval, Y)
addY(XCluster, Y)
View(XCluster)
addY <- function(X, Y){
X$target <- Y
return(X)
}
addY(XEqualFreq, Y)
addY(XEqualInterval, Y)
addY(XCluster, Y)
X[1] <- addY(XEqualFreq, Y)
X <- list()
X[1] <- addY(XEqualFreq, Y)
X <- list()
X[[1]] <- addY(XEqualFreq, Y)
X[[2]] <- addY(XEqualInterval, Y)
X[[3]] <- addY(XCluster, Y)
fnClf <- function(X, Y, trainIndex){
Xtrain <- X[trainIndex, ]
Xtest <- X[-trainIndex, ]
Ytrain <- Y[trainIndex]
Ytest <- Y[-trainIndex]
model <- NaiveBayes(Ytrain~Xtrain)
Ypred <- predict(model, Xtest)
confusionMatrix(Ypred$class, Ytest)
}
fnClf <- function(X, Y, trainIndex){
Xtrain <- X[trainIndex, ]
Xtest <- X[-trainIndex, ]
Ytrain <- Xtrain$target
Ytest <- Xtest$target
model <- NaiveBayes(target~., data = Xtrain)
Ypred <- predict(model, Xtest)
confusionMatrix(Ypred$class, Ytest)
}
fnClf <- function(X, trainIndex){
Xtrain <- X[trainIndex, ]
Xtest <- X[-trainIndex, ]
Ytrain <- Xtrain$target
Ytest <- Xtest$target
model <- NaiveBayes(target~., data = Xtrain)
Ypred <- predict(model, Xtest)
confusionMatrix(Ypred$class, Ytest)
}
fnClf(X[[1]], trainIndex)
install.packages("e1071")
library(e1071)
fnClf <- function(X, trainIndex){
Xtrain <- X[trainIndex, ]
Xtest <- X[-trainIndex, ]
Ytrain <- Xtrain$target
Ytest <- Xtest$target
model <- NaiveBayes(target~., data = Xtrain)
Ypred <- predict(model, Xtest)
confusionMatrix(Ypred$class, Ytest)
}
fnClf(X[[1]], trainIndex)
# equal frequency
for (i in 1:3){
cat("***** current list: ", i)
fnClf(X[[1]], trainIndex)
}
for (i in 1:3){
cat("***** current list: ", i)
fnClf(X[[i]], trainIndex)
}
for (i in 1:3){
cat("***** current list: ", i)
print(fnClf(X[[i]], trainIndex))
}
XFixed <- colwise(fnDisc)(dataTrain[1:3], method='fixed')
datatFinal <- X[[1]]
dataFinal <- X[[1]]
dataFinal$name <- data$基金会名称
View(datatFinal)
dataFinal <- dataFinal$name <- data$基金会名称
View(datatFinal)
XFinal <- dataFinal$name <- data$基金会名称
View(datatFinal)
cols
df <- data.frame(data[cols[1]], dataFinal)
View(df)
dataFinal <- X[[1]]
data[cols[1]]
dataFinal <- X[[1]]
dataFinal
rbind(data[cols[1]], dataFinal)
cbind(data[cols[1]], dataFinal)
dataFinal <- cbind(data[cols[1]], dataFinal)
write.csv("./data/基金会财务信息年分权重后提取关键列（分类后）.csv")
write.csv(dataFinal, "./data/基金会财务信息年分权重后提取关键列（分类后）.csv")
XEqualFreq
xEqualFreq <- discretize(x, method = 'frequency', categories = 3, labels = c(0, 1, 2))
xEqualFreq
View(dataTrain)
Xjinzichan <- cbind(dataFinal$净资产, dataTrain$净资产)
View(Xjinzichan)
??aggregate
Xjinzichan
colnames(Xjinzichan)
colnames(Xjinzichan) <- c('v1', 'v2')
colnames(Xjinzichan) <- c('v1', 'v2')
aggregate(x = v2, by = b1, FUN='mean')
colnames(Xjinzichan)
aggregate(x = Xjinzichan$v2, by = Xjinzichan$v1 , FUN='mean')
aggregate(x = Xjinzichan[,2], by = Xjinzichan[,1] , FUN='mean')
unique.array(Xjinzichan[, 2])
aggregate(x = Xjinzichan[,2], by = c(1,2,3), FUN=min)
aggregate(x = Xjinzichan[,2], by = list(1:3), FUN=min)
Xjinzichan[,2]
aggregate(x = Xjinzichan[,2], by = list(Xjinzichan[, 1]), FUN=min)
aggregate(x = Xjinzichan[, 2], by = list(Xjinzichan[, 1]), FUN=min)
table(Xjinzichan[, 2])
unique(table(Xjinzichan[, 2]))
table(Xjinzichan[, 2])
table(Xjinzichan[, 1])
aggregate(x = Xjinzichan[, 2], by = list(Xjinzichan[, 1]), FUN=min)
Zongshouru <- cbind(dataFinal$总收入, dataTrain$总收入)
colnames(Zongshouru) <- c('v1', 'v2')
aggregate(x = Xjinzichan[, 2], by = list(Xjinzichan[, 1]), FUN=mean)
Zongshouru <- cbind(dataFinal$总收入, dataTrain$总收入)
colnames(Zongshouru) <- c('v1', 'v2')
aggregate(x = Xjinzichan[, 2], by = list(Xjinzichan[, 1]), FUN=desc())
aggregate(x = Zongshouru[, 2], by = list(Zongshouru[, 1]), FUN=mean)
Zongzhichu <- cbind(dataFinal$总收入, dataTrain$总支出)
colnames(Zongzhichu) <- c('v1', 'v2')
aggregate(x = Zongzhichu[, 2], by = list(Zongzhichu[, 1]), FUN=mean)
Zongzhichu <- cbind(dataFinal$总收入, dataTrain$总支出)
colnames(Zongzhichu) <- c('v1', 'v2')
aggregate(x = Zongzhichu[, 2], by = list(Zongzhichu[, 1]), FUN=mean)
View(datatFinal)
# discretization finantial data -------------------------------------------
data <- read.csv("./data/基金会财务信息年分权重后结果统计（分类后）.csv", encoding = "utf-8")
cols <- colnames(data)
choiceCol <- cols[c(7, 12, 11, 22, 23)]
dataTrain <- data[choiceCol]
# to make shou ru, zhi chu, fei yong smaller than 1
dataTrain[2] <- dataTrain[2] / dataTrain[1]
dataTrain[3] <- dataTrain[3] / dataTrain[1]
dataTrain[4] <- dataTrain[4] / dataTrain[1]
head(dataTrain, n = 2)
Y <- dataTrain$label
XEqualFreq <- colwise(fnDisc)(dataTrain[c(1:4)], method='frequency')
XEqualInterval <- colwise(fnDisc)(dataTrain[1:4], method='interval')
XCluster <- colwise(fnDisc)(dataTrain[1:4], method='cluster')
X <- list()
X[[1]] <- addY(XEqualFreq, Y)
X[[2]] <- addY(XEqualInterval, Y)
X[[3]] <- addY(XCluster, Y)
split = 0.6
trainIndex <- createDataPartition(dataTrain$label, p = split, list=FALSE)
fnClf <- function(X, trainIndex){
Xtrain <- X[trainIndex, ]
Xtest <- X[-trainIndex, ]
Ytrain <- Xtrain$target
Ytest <- Xtest$target
model <- NaiveBayes(target~., data = Xtrain)
Ypred <- predict(model, Xtest)
confusionMatrix(Ypred$class, Ytest)
}
# equal frequency
for (i in 1:3){
cat("***** current list: ", i)
print(fnClf(X[[i]], trainIndex))
}
# equal frequency
for (i in 1:3){
cat("***** current list: ", i)
print(fnClf(X[[i]], trainIndex))
}
library(discretization)
dataTrain$label <- as.factor(dataTrain$label)
Y <- dataTrain$label
XEqualFreq <- colwise(fnDisc)(dataTrain[c(1:4)], method='frequency')
XEqualInterval <- colwise(fnDisc)(dataTrain[1:4], method='interval')
XCluster <- colwise(fnDisc)(dataTrain[1:4], method='cluster')
X <- list()
X[[1]] <- addY(XEqualFreq, Y)
X[[2]] <- addY(XEqualInterval, Y)
X[[3]] <- addY(XCluster, Y)
# equal frequency
for (i in 1:3){
cat("***** current list: ", i)
print(fnClf(X[[i]], trainIndex))
}
dataFinal <- X[[1]]
dataFinal <- cbind(data[cols[1]], dataFinal)
write.csv(dataFinal, "./data/基金会财务信息年分权重后提取关键列（分类后）.csv")
Xjinzichan <- cbind(dataFinal$净资产, dataTrain$净资产)
colnames(Xjinzichan) <- c('v1', 'v2')
aggregate(x = Xjinzichan[, 2], by = list(Xjinzichan[, 1]), FUN=mean)
Zongshouru <- cbind(dataFinal$总收入, dataTrain$总收入)
colnames(Zongshouru) <- c('v1', 'v2')
aggregate(x = Zongshouru[, 2], by = list(Zongshouru[, 1]), FUN=mean)
Zongzhichu <- cbind(dataFinal$总收入, dataTrain$总支出)
colnames(Zongzhichu) <- c('v1', 'v2')
aggregate(x = Zongzhichu[, 2], by = list(Zongzhichu[, 1]), FUN=mean)
Zongfeiyong<- cbind(dataFinal$费用合计, dataTrain$费用合计)
colnames(Zongfeiyong) <- c('v1', 'v2')
# Zong zhi chu
aggregate(x = Zongfeiyong[, 2], by = list(Zongfeiyong[, 1]), FUN=mean)
# Group.1          x
# 1       1 -0.2957747
# 2       2  0.3089209
# 3       3  1.8594327
View(datatFinal)
View(dataFinal)
write.csv(dataFinal, "./data/基金会财务信息年分权重后提取关键列（分类后）.csv")
